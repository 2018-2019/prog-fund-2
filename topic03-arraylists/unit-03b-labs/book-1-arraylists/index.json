


  {
  
  
    "properties" : {},
  
  "type" : "lab",
  "title" : "Lab-03",
  "img" : "img/main.png",
  "videoid" : "none",
  "objectives" : "<p>Collections · Generic Classes · ArrayList · loops · for each loop · Menu Driven Apps</p>",
  "folder" : "book-1-arraylists",
  "link" : "index.html",
  "los": [
   ]
,
  "chapters" : [
  
    {
    "title": "#Objectives",
    "shortTitle": "Lab-03",
    "contentMd" : "#Objectives\r\n\r\nCollections · Generic Classes · ArrayList · loops · for each loop · Menu Driven Apps\r\n"
    },
  
    {
    "title": "#Starting ShopV3.0",
    "shortTitle": "01",
    "contentMd" : "#Starting ShopV3.0\r\n\r\nIn this step, you will use the ShopV2.2 solution as a starting point for Shop V3.0.  In this version:\r\n\r\n- you will remove the primitive array and use an ArrayList instead.\r\n\r\n\r\n##Creating ShopV3.0\r\n\r\nThe solution to the previous lab (i.e. ShopV2.2) is [here](./archives/ShopV2.2.zip).\r\n\r\nIn IntelliJ, create a new project called ShopV3.0.  \r\n\r\nCopy the src files (Driver, Store, Product) from ShopV2.2 and paste them in the src for ShopV3.0.\r\n\r\n![ShopV3.0 folder structure](./img/01.PNG)\r\n\r\n\r\n##Test the code base\r\n\r\nRun your version of ShopV3.0 to both test it and also familiarise yourself with the project. \r\n\r\n"
    },
  
    {
    "title": "#Refactoring the Store Class",
    "shortTitle": "02",
    "contentMd" : "#Refactoring the Store Class\r\n\r\nIn this step, you will refactor (change) the Store class so that it no longer uses a primitive array, but uses an ArrayList instead.\r\n\r\n\r\n##Import the ArrayList class\r\n\r\nTo use the ArrayList in our Store class, we need to import it:\r\n\r\n~~~java\r\nimport java.util.ArrayList;\r\n~~~\r\n\r\n\r\n##Declaring an ArrayList\r\n\r\nCurrently we are using a primitive array and we keep track of how many items are added using the **total** field:\r\n\r\n~~~java\r\n\tprivate Product[] products;\r\n\tprivate int total;\r\n~~~\r\n\r\nAs an ArrayList automatically grows and shrinks as you add/remove elements, there is no need for the **total** field anymore. Delete this field.\r\n\r\nThe **products** instance field should be changed to this:\r\n\r\n~~~java\r\n    private ArrayList<Product> products;\r\n~~~\r\n\r\n\r\n##The Store Constructor\r\n\r\nCurrently the Store constructor looks like this:\r\n\r\n~~~java\r\n\tpublic Store(int numberItems){\r\n\t\tproducts = new Product[numberItems];\r\n\t\ttotal = 0;\r\n\t}\r\n~~~\r\n\r\nAs an ArrayList doesn't need to know the maximum number of items that will be stored, we can delete the parameter **numberItems**.  We can also remove the initialisation of **total**.  We will instantiate the **products** ArrayList too, instead of a primitive array instantiation.  Your constructor should now look like this:\r\n\r\n~~~java\r\n\tpublic Store(){\r\n\t\tproducts = new ArrayList<Product>();\r\n\t}\r\n~~~\r\n\r\n\r\n##The add method\r\n\r\nCurrently the **add** method looks something like this (see code below).  As a primitive array has a maximum capacity, you have to check if the array is full before attempting to add a Product to it.  As the add can fail due to space restrictions, you also need to return a boolean status for the add.  The total field also needed to be maintained.\r\n\r\n~~~java\r\n\t    public boolean add(Product product){\r\n        if (isFull()){\r\n            return false;\r\n        }\r\n        else{\r\n            products[total] = product;\r\n            total++;\r\n            return true;\r\n        }\r\n    }\r\n~~~\r\n\r\nAs the ArrayList grows when you add Product objects to it, you don't need to check for spare capacity, check for successful adds, nor do you have to maintain the total items entered (an ArrayList does this for us).  Replace the above **add** method with our new **add** method, which will simply look like this:\r\n\r\n~~~java\r\n    public void add (Product product){\r\n        products.add (product); \r\n    }\r\n~~~\r\n\r\n\r\n##The listProducts method\r\n\r\nCurrently the **listProducts** method looks like this:\r\n\r\n~~~java\r\n    public String listProducts(){\r\n        if (isEmpty()){\r\n            return \"No products\";\r\n        }\r\n        else{\r\n            String listOfProducts = \"\";\r\n            for (int i = 0; i < total; i++){\r\n                listOfProducts = listOfProducts + i + \": \" + products[i] + \"\\n\";\r\n            }\r\n            return listOfProducts;\r\n        }\r\n    }\r\n~~~\r\n\r\nRewrite the method so that it looks like this:\r\n\r\n~~~java\r\n\tpublic String listProducts(){\r\n\t\tif (products.size() == 0){\r\n\t\t\treturn \"No products\";\r\n\t\t}\r\n\t\telse{\r\n\t\t\tString listOfProducts = \"\";\r\n\t\t\tfor (int i = 0; i < products.size(); i++){\r\n\t\t\t\tlistOfProducts = listOfProducts + i + \": \" + products.get(i) + \"\\n\";\r\n\t\t\t}\r\n\t\t\treturn listOfProducts;\r\n\t\t} \r\n\t}\r\n~~~\r\n\r\nOr if you prefer to use the for-each loop, you can replace it with this:\r\n\r\n~~~\r\n    public String listProducts(){\r\n\t\tif (products.size() == 0){\r\n\t\t\treturn \"No products\";\r\n\t\t}\r\n\t\telse{\r\n\t\t\tString listOfProducts = \"\";\r\n\t\t\tint index = 0;\r\n\t\t\tfor (Product product : products){\r\n\t\t\t\tlistOfProducts = listOfProducts + index + \": \" + product + \"\\n\";\r\n\t\t\t\tindex ++;\r\n\t\t\t}\r\n\t\t\treturn listOfProducts;\r\n\t\t} \r\n\t}\r\n~~~\r\n\r\n\r\n##The listCurrentProducts method\r\n\r\nHaving rewritten the **listProducts** method, refactor the **listCurrentProducts** method body so that it is the exact same.\r\n\r\nInclude, inside the for loop, the following test so that only those products in the current product line are added to the String to be returned:\r\n\r\n~~~\r\n    if (products.get(i).isInCurrentProductLine())            \r\n~~~  \t\t\t\t\r\n\r\n\r\n##The listProductsAboveAPrice method\r\n\r\nHaving worked on the other two **list** methods above, have a go at converting **listProductsAboveAPrice** to handle **ArrayList** instead of a **primitive array**.\r\n\r\n\r\n##The averageProductPrice method\r\n\r\nCurrently, the **averageProductPrice** method looks like this:\r\n\r\n~~~java\r\n    public double averageProductPrice()\r\n\t{ \r\n\t\tif (!isEmpty()){\r\n\t\t\tdouble totalPrice = 0;\r\n\t\t\tfor (int i = 0; i < total; i++){\r\n\t\t\t\ttotalPrice = totalPrice + products[i].getUnitCost();\r\n\t\t\t}\r\n\t\t\treturn totalPrice / products.length;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn 0.0;\r\n\t\t}\r\n\r\n\t}\r\n~~~\r\n\r\nRefactor the method so that it looks like the code below.  Note that we have catered for an empty ArrayList...we don't want to accidentally divide by zero as it will crash our program (DivideByZeroException).\r\n\r\n~~~\r\n\tpublic double averageProductPrice()\r\n\t{ \r\n\t\tif (products.size() != 0){\r\n\t\t\tdouble totalPrice = 0;\r\n\t\t\tfor (int i = 0; i < products.size(); i++){\r\n\t\t\t\ttotalPrice = totalPrice + products.get(i).getUnitCost();\r\n\t\t\t}\r\n\t\t\treturn totalPrice / products.size();\r\n\t\t}\r\n\t\telse{\r\n\t\t\treturn 0.0;\r\n\t\t}\r\n\t}\r\n~~~\r\n\r\n\r\n##The cheapestProduct method\r\n\r\nHaving refactored the previous methods, have a go at converting the **cheapestProduct** method to handle **ArrayList** instead of a **primitive array**.\r\n\r\n\r\n##isEmpty and isFull methods\r\n\r\nThere is no need for these methods when using ArrayLists, so you can simply delete them.\r\n\r\n\r\n"
    },
  
    {
    "title": "#Refactoring the Driver Class",
    "shortTitle": "03",
    "contentMd" : "#Refactoring the Driver Class\r\n\r\nIn this step, you will refactor (change) the Driver class so that any changes we made to the public **Interface** of the Store class are reflected in this class.\r\n\r\n\r\n##Store Constructor\r\n\r\nThe only change that we made to the public **Interface** of the Store class is the Store Constructor.\r\n\r\nBy using an ArrayList, we removed the need to know the size of the collection at the start of the program.  For this reason we deleted the numberItems from the Store constructor's parameter list. \r\n\r\nIn the Driver class, in the processOrder method, you will find this code:\r\n\r\n~~~java\r\n    //find out from the user how many products they would like to order\r\n    System.out.print(\"How many Products would you like to have in your Store?  \");\r\n    int numberProducts = input.nextInt();\r\n    \r\n    store = new Store(numberProducts);\r\n~~~\r\n\r\nFor the moment, leave the code in that asks the user how many products they want to enter (we will come back to this later!).\r\n\r\nJust remove the parameter that is passed to the Store constructor.  This line of code should now be:\r\n\r\n~~~java\r\n    store = new Store();\r\n~~~\r\n\r\n\r\n##Run and Test\r\n\r\nTry running your code; the functionality for the user should not have changed in any way.  \r\n\r\nYour output should look similar to this:\r\n\r\n![](./img/06.PNG)\r\n\r\n"
    },
  
    {
    "title": "#Enhancing the Menu",
    "shortTitle": "04",
    "contentMd" : "#Enhancing the Menu\r\n\r\nAt this stage, you should have refactored ShopV3.0 so that it uses an ArrayList instead of a primitive array.  If you had difficulty with it, [here is an interim solution](./archives/ShopV3.0-InterimSolution.zip) that you can use for the rest of this lab.\r\n\r\nYou will notice in our code that we are still asking the user how many products they want to add:\r\n\r\n![](./img/06.PNG)\r\n\r\nThis is very restrictive for a user; they cannot add more products later on.  We need to change our menu so that we can give the user control over adding items to our app.\r\n\r\n\r\n##Refactoring the menu\r\n\r\nAs the **Driver** class controls all the I/O, our changes will be made in this class; Store and Product will not change.\r\n\r\nWe want the following menu displayed: \r\n\r\n![](./img/07.PNG)\r\n\r\nFirst, refactor your *mainMenu* method so that it includes the following options (note the number change for some menu items):\r\n\r\n~~~java\r\n    private int mainMenu(){\r\n        System.out.println(\"Shop Menu\");\r\n        System.out.println(\"---------\");\r\n        System.out.println(\"  1) Add a product\");\r\n        System.out.println(\"  2) List the Products\");\r\n        System.out.println(\"  --------------------\");\r\n        System.out.println(\"  3) List the current products\");\r\n        System.out.println(\"  4) Display average product unit cost\");\r\n        System.out.println(\"  5) Display cheapest product\");\r\n        System.out.println(\"  6) List products that are more expensive than a given price\");\r\n        System.out.println(\"  --------------------\");\r\n        System.out.println(\"  0) Exit\");\r\n        System.out.print(\"==>> \");\r\n        int option = input.nextInt();\r\n        return option;\r\n    }\r\n~~~\r\n\r\nThen refactor the *runMenu* method to be:\r\n\r\n~~~java\r\n    private void runMenu(){\r\n        int option = mainMenu();\r\n        while (option != 0){\r\n\r\n            switch (option){\r\n                case 1:    addProduct();\r\n                    break;\r\n                case 2:    System.out.println(store.listProducts());\r\n                    break;\r\n                case 3:    printCurrentProducts();\r\n                    break;\r\n                case 4:    printAverageProductPrice();\r\n                    break;\r\n                case 5:    printCheapestProduct();\r\n                    break;\r\n                case 6:    printProductsAboveAPrice();\r\n                    break;\r\n                default:    System.out.println(\"Invalid option entered: \" + option);\r\n                    break;\r\n            }\r\n\r\n            //pause the program so that the user can read what we just printed to the terminal window\r\n            System.out.println(\"\\nPress any key to continue...\");\r\n            input.nextLine();\r\n            input.nextLine();  //this second read is required - bug in Scanner class; a String read is ignored straight after reading an int.\r\n\r\n            //display the main menu again\r\n            option = mainMenu();\r\n        }\r\n\r\n        //the user chose option 0, so exit the program\r\n        System.out.println(\"Exiting... bye\");\r\n        System.exit(0);\r\n    }\r\n~~~\r\n\r\nAs the menu is going to control the adding of the products, we no longer need the *processOrder* method.  You can delete this method and the call made to the method. \r\n\r\nThe final change that we need to make is to the *store* field...when we deleted the processOrder method, we deleted the *instantiation* of this field.  In the Driver constructor, instantiate the store object:\r\n\r\n~~~java\r\n    public Driver() {\r\n        store = new Store();\r\n        runMenu();\r\n    }\r\n~~~\r\n\r\n\r\n##Run the App\r\n\r\nRun the app; does all work as expected?  Does each menu option do what it is supposed to do? \r\n\r\nTest the menu with some of your own products and see if you can identify any bugs.  If you come across any, try fix them.\r\n\r\nBefore moving onto the next step, it is a good idea to familiarise yourself with the code in both the Store and the Driver class.  Note that we made no changes to the Product class. \r\n\r\n"
    },
  
    {
    "title": "#Formatting decimal output",
    "shortTitle": "05",
    "contentMd" : "#Formatting decimal output\r\n\r\nDid you notice that the average product price is not limited to two decimal places?\r\n\r\n![Average product price](./img/08.PNG)\r\n\r\n\r\n##toTwoDecimalPlaces\r\n\r\nWe are going to just truncate this to two decimal places.\r\n\r\nAdd the following helper method towards the bottom of the Store class:\r\n\r\n~~~java\r\n    private double toTwoDecimalPlaces(double num){\r\n        return (int) (num *100 ) /100.0; \r\n    }\r\n~~~\r\n\r\nCurrently, your **averageProductPrice** method should look something like this:\r\n\r\n~~~java\r\n    public double averageProductPrice()\r\n    {\r\n        if (products.size() != 0){\r\n            double totalPrice = 0;\r\n            for (int i = 0; i < products.size(); i++){\r\n                totalPrice = totalPrice + products.get(i).getUnitCost();\r\n            }\r\n            return totalPrice / products.size();\r\n        }\r\n        else{\r\n            return 0.0;\r\n        }\r\n    }\r\n~~~\r\n\r\nWhen returning the result of the average calculation, we want to call our new **toTwoDecimalPlaces** method to truncate the result to two decimal places:\r\n\r\n~~~java\r\n    public double averageProductPrice()\r\n    {\r\n        if (products.size() != 0){\r\n            double totalPrice = 0;\r\n            for (int i = 0; i < products.size(); i++){\r\n                totalPrice = totalPrice + products.get(i).getUnitCost();\r\n            }\r\n            return toTwoDecimalPlaces(totalPrice / products.size());\r\n        }\r\n        else{\r\n            return 0.0;\r\n        }\r\n    }\r\n~~~\r\n\r\nMake this change and test your app to make sure your result is truncated to two decimal places (note:  this method does not round up/down, it simply truncates).\r\n\r\n"
    },
  
    {
    "title": "#Exercises",
    "shortTitle": "Exercises",
    "contentMd" : "#Exercises\r\n\r\nOver the next few weeks, we will use the knowledge we glean from the **Shop** project to build a Menu Driven **DVDLibrary** app.  \r\n\r\nToday, you will work on Phase 1 of this DVDLibrary application; it presents the user with a simple menu for adding and listing DVD titles.\r\n\r\n\r\n#Menu Driven DVD app - phase 1\r\n\r\nCreate a new project called **DVDLibraryV1.0**. \r\n\r\n\r\n##DVD class\r\n\r\nWithin this project, create a new class called **DVD**. In this class:\r\n\r\n- Add an instance field, called **title**, that will store the title of the DVD.\r\n\r\n- Add a default empty constructor (we will cover why in later labs). \r\n\r\n- Add a constructor that takes in the title as a parameter and updates the instance field, **title**.\r\n\r\n- Add an accessor and a mutator for the **title** field.\r\n\r\n- Add a toString method that formats the object state to a user-friendly string.\r\n       \r\n\r\n##Library class\r\n\r\nWithin the current project, create a new class called **Library**. In this class:\r\n\r\n- Add an instance field called **dvds** that can hold an ArrayList of DVDs.\r\n\r\n- Add a constructor that instantiates the above ArrayList.\r\n\r\n- Add a method **add()** that accpets a DVD object as a parameter. This method should add the passed DVD object to the **dvds** ArrayList.\r\n\r\n- Add a method **listDVDs()** that *returns* a String comprising the index number and the title of each DVD in the dvds ArrayList.  If there are no dvds in the ArrayList, the String \"No DVDs\" should be returned.\r\n\r\n\r\n##Driver class\r\n\r\nWithin the current project, create a new class called **Driver**. In this class:\r\n\r\n- Add an instance field called **library** that is of type **Library**.\r\n\r\n- Add an instance field called **input** that is of type **Scanner**.\r\n\r\n- Add a constructor that instantiates the above **library** field and the above **input** field.\r\n\r\n- Add a private method called **addDVD()** that has a void return type.  This method should read the title of the DVD from the user.  It should also include the following line of code to add the DVD to the dvds collection in Library:\r\n\r\n~~~java\r\n    library.add(new DVD(dvdTitle));\r\n~~~ \r\n\r\n- NOTE:  This line of code:\r\n\r\n    - creates a DVD object with the title entered by the user.\r\n\r\n    - calls the **add** method in the Library class to add the DVD object to the **dvds** ArrayList. \r\n\r\n\r\n- Add a private method **mainMenu()** that has an int return type.  This method should display the name of the menu and the menu options (see image below).  This method should read the menu option that the user entered and return it.\r\n\r\n![Menu for the DVD Library](./img/09.PNG) \r\n\r\n- Add a private method **run()** that has a void return type.  This method should look like this:\r\n\r\n~~~java\r\n    private void run()\r\n    {\r\n        int option = mainMenu();\r\n        while (option != 0)\r\n        {\r\n            switch (option)\r\n            {\r\n                case 1:\r\n                    addDVD();\r\n                    break;\r\n                case 2:\r\n                    System.out.println(library.listDVDs());\r\n                    break;\r\n                default:\r\n                    System.out.println(\"Invalid option selected.\");\r\n                    break;\r\n            }\r\n\r\n            //display the main menu again\r\n            System.out.println(\"\");\r\n            option = mainMenu();\r\n        }\r\n        System.out.println(\"Exiting... bye\");\r\n    }\r\n~~~\r\n        \r\n- Finally, write a main method that will create an instance of itself (i.e. the Driver class) and call the **run** method over this instance (see the code below).\r\n\r\n~~~java\r\n    public static void main (String[] args)\r\n     {\r\n         Driver app = new Driver();\r\n         app.run();\r\n     }\r\n~~~\r\n\r\n\r\n##Run and Test\r\n\r\nRun the project.\r\n\r\nTest by adding a series of DVDs and listing them.  \r\n\r\nAlso try listing the DVDs when no DVDs have been entered (you can test this by restarting the application to clear any existing DVDs).\r\n\r\n\r\n"
    },
  
    {
    "title": "#Solutions",
    "shortTitle": "Solutions",
    "contentMd" : "#Solutions\r\n\r\n[ShopV2.1 from the previous lab](archives/ShopV2.1.zip)\r\n\r\n[ShopV2.2 from the previous lab](archives/ShopV2.2.zip)\r\n\r\n[ShopV3.0-InterimSolution](archives/ShopV3.0-InterimSolution.zip)\r\n\r\n[ShopV3.0](archives/ShopV3.0.zip)\r\n\r\n[Exercise Solution - DVDLibraryV1.0](archives/DVDLibraryV1.0.zip)\r\n\r\n"
    }
  
  ]
  }

